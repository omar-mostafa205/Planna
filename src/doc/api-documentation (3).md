"# API Reference Documentation\n\n## Overview\n\n**Technology Stack:**\n*   **Web Framework:** Next.js (App Router)\n*   **Authentication:** Clerk\n*   **Database ORM:** Prisma\n*   **Payments:** Stripe\n*   **AI / LLM Provider:** OpenAI (via OpenRouter)\n*   **Image Processing:** Sharp\n*   **Validation (Client-side):** Zod\n*   **Language:** TypeScript\n\n**Base URL:**\nThe codebase uses `process.env.NEXT_PUBLIC_URL` to construct success and cancel URLs for Stripe Checkout.\n\n*   **Code Reference:** `src/app/api/check-out/route.ts`\n    ```typescript\n    // ...\n      success_url: `${process.env.NEXT_PUBLIC_URL}/success?session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${process.env.NEXT_PUBLIC_URL}/cancel`,\n    // ...\n    ```\n\n**API Version:**\nUnable to determine from codebase. The `package.json` file content was not provided.\n\n**Summary:**\nThis API provides services for an AI-powered nutrition planning application named \"Planna\". It handles user profile creation via Clerk webhooks, generates personalized meal plans using OpenAI based on user-submitted data (including InBody scan images), and manages user subscriptions through Stripe Checkout and webhooks. The core functionality revolves around creating, storing, and retrieving user-specific meal plans.\n\n---\n\n## Authentication\n\n### Authentication Method\n\n**Type Detected:** Clerk (JWT-based)\n\n**Implementation Location:**\n*   Middleware: `omar-mostafa205-Planna-aea2b49/src/middleware.ts`\n*   API Route Protection: `omar-mostafa205-Planna-aea2b49/src/app/api/generate-plan/route.ts`, `omar-mostafa205-Planna-aea2b49/src/app/api/get-plan/route.ts`\n\n**How Authentication Works:**\nThe application uses Clerk for user authentication. A middleware (`clerkMiddleware`) is applied to all relevant routes to manage authentication state. Protected API endpoints call the `auth()` function from `@clerk/nextjs/server` to retrieve the authenticated user's ID (`userId`). If no authenticated user is found, the endpoint typically returns an unauthorized response.\n\n**Code Reference:**\n*   Middleware Configuration (`src/middleware.ts`):\n    ```typescript\n    import { clerkMiddleware } from \"@clerk/nextjs/server\";\n\n    export default clerkMiddleware();\n\n    export const config = {\n      matcher: [\n        // Skip Next.js internals and all static files, unless found in search params\n        '/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',\n        // Always run for API routes\n        '/(api|trpc)(.*)',\n      ],\n    };\n    ```\n*   Protecting an API Route (`src/app/api/get-plan/route.ts`):\n    ```typescript\n    import { auth } from \"@clerk/nextjs/server\";\n\n    export async function GET() {\n      const { userId } = await auth();\n\n      if (!userId) {\n        return new NextResponse(JSON.stringify({ error: \"Unauthorized\" }), {\n          status: 401,\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      }\n      // ... handler logic\n    }\n    ```\n\n### Authentication Flow\nThe system relies on Clerk's hosted pages for sign-up and sign-in. When a new user is created in Clerk, a webhook is sent to this application to create a corresponding user profile in the local database.\n\n**User Profile Creation (via Webhook):**\nThe `POST /api/webhook/clerk` endpoint listens for user creation events from Clerk to synchronize user data.\n\n*   **Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/webhook/clerk/route.ts`\n*   **Handler Code:**\n    ```typescript\n    // ...\n        const { data } = await req.json() as { data: any };\n\n        switch (data?.object) {\n            case 'user':\n                console.log('User event received:', data);\n\n                const email = data?.email_addresses?.[0]?.email_address;\n                const clerkUserId = data?.id;\n\n                if (!clerkUserId || !email) {\n                    return new NextResponse(JSON.stringify({ error: 'Missing user ID or email' }), { status: 400 });\n                }\n\n                // Use a transaction for upserting the profile\n                const profile = await prisma.$transaction(async (tx) => {\n                    return tx.profile.upsert({\n                        where: { userId: clerkUserId },\n                        create: {\n                            userId: clerkUserId,\n                            email,\n                            subscriptionActive: false,\n                            subscriptionTier: null,\n                            stripeSubscriptionId: null,\n                        },\n                        update: { email },\n                    });\n                });\n    // ...\n    ```\n\n---\n\n## API Endpoints\n\n### Meal Plan\n\n#### `POST /api/generate-plan`\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/generate-plan/route.ts:29`\n\n**Description:** Generates a personalized meal plan for the authenticated user using OpenAI. It processes user-provided information and an optional InBody scan image to create the plan, then saves it to the user's profile in the database.\n\n**Authentication Required:** Yes\n\n**Route Handler:**\n```typescript\nimport { auth } from \"@clerk/nextjs/server\";\nimport { prisma } from \"@/lib/prisma\";\n// ...\n\nexport async function POST(req: Request) {\n  const { userId } = await auth();\n\n  if (!userId) {\n    return new NextResponse(JSON.stringify({ error: \"Unauthorized\" }), {\n      status: 401,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  try {\n    const formData = await req.formData();\n    const data = {\n      fullName: formData.get(\"fullName\") as string,\n      age: formData.get(\"age\") as string,\n      height: formData.get(\"height\") as string,\n      gender: formData.get(\"gender\") as string,\n      activityLevel: formData.get(\"activityLevel\") as string,\n      goals: formData.get(\"goals\") as string,\n      medicalConditions: formData.get(\"medicalConditions\") as string || \"\",\n      images: formData.getAll(\"images\") as File[],\n    };\n\n    // ... OpenAI and image processing logic ...\n\n    const mealPlanJson = JSON.parse(mealPlan.choices[0].message.content!);\n\n    // Save the plan to the database\n    await prisma.profile.update({\n      where: { userId },\n      data: { mealPlan: mealPlanJson },\n    });\n\n    return new NextResponse(JSON.stringify(mealPlanJson), {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n\n  } catch (error) {\n    console.error(\"Error generating meal plan:\", error);\n    return new NextResponse(JSON.stringify({ error: \"Failed to generate meal plan\" }), {\n      status: 500,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  }\n}\n```\n\n**Request Body Schema:**\nThe request body is expected to be `multipart/form-data`. The following fields are extracted from the form data in the handler:\n\n| Field | Type | Description |\n|---|---|---|\n| `fullName` | `string` | The user's full name. |\n| `age` | `string` | The user's age. |\n| `height` | `string` | The user's height in centimeters. |\n| `gender` | `string` | The user's gender (e.g., \"Male\", \"Female\"). |\n| `activityLevel` | `string` | The user's activity level (e.g., \"Sedentary\"). |\n| `goals` | `string` | The user's health and fitness goals. |\n| `medicalConditions` | `string` | Any relevant medical conditions. Optional. |\n| `images` | `File[]` | An array of files. The handler processes the first image as an InBody scan. |\n\n**Response Schema:**\nThe endpoint returns the JSON object of the generated meal plan received from OpenAI. The structure is defined by the prompt in the handler. A client-side interface matches this structure.\n\n*   **Source:** `omar-mostafa205-Planna-aea2b49/src/app/(main)/dashboard/page.tsx`\n    ```typescript\n    interface Meal {\n      title: string;\n      calories: number;\n      protein: number;\n      carbs: number;\n      fat: number;\n      ingredients: string[];\n      instructions: string[];\n    }\n\n    interface MealPlanData {\n      calories: number;\n      protein: number;\n      carbs: number;\n      fat: number;\n      currentWeight: number;\n      bodyFat: number;\n      muscleMass: number;\n      goal: string;\n      meals: {\n        breakfast: Meal;\n        lunch: Meal;\n        dinner: Meal;\n        snack: Meal;\n      };\n    }\n    ```\n\n**Error Responses:**\n\n| Status Code | Condition | Response |\n|---|---|---|\n| `401` | User is not authenticated. | `{\"error\": \"Unauthorized\"}` |\n| `500` | An error occurs during image processing, OpenAI API call, or database update. | `{\"error\": \"Failed to generate meal plan\"}` |\n\n**Database Operations:**\n*   Writes to: `Profile` (updates the `mealPlan` field).\n\n---\n\n#### `GET /api/get-plan`\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/get-plan/route.ts:6`\n\n**Description:** Retrieves the meal plan for the currently authenticated user from the database.\n\n**Authentication Required:** Yes\n\n**Route Handler:**\n```typescript\nimport { NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@clerk/nextjs/server\";\n\nexport async function GET() {\n  const { userId } = await auth();\n\n  if (!userId) {\n    // ... 401 response\n  }\n\n  try {\n    const profile = await prisma.profile.findUnique({\n      where: { userId },\n      select: { mealPlan: true }\n    });\n\n    if (!profile || !profile.mealPlan) {\n      return new NextResponse(JSON.stringify({ error: \"No meal plan found\" }), {\n        status: 404,\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n    return NextResponse.json(profile.mealPlan);\n  } catch (error) {\n    // ... 500 response\n  }\n}\n```\n\n**Response Schema:**\nReturns the `mealPlan` JSON object stored in the user's profile. See the schema for `POST /api/generate-plan`.\n\n**Error Responses:**\n\n| Status Code | Condition | Response |\n|---|---|---|\n| `401` | User is not authenticated. | `{\"error\": \"Unauthorized\"}` |\n| `404` | No profile exists for the user or the `mealPlan` field is null. | `{\"error\": \"No meal plan found\"}` |\n| `500` | A database error occurred. | `{\"error\": \"Failed to fetch meal plan\"}` |\n\n**Database Operations:**\n*   Reads from: `Profile` (selects the `mealPlan` field).\n\n---\n\n### Payments & Subscriptions\n\n#### `POST /api/check-out`\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/check-out/route.ts:6`\n\n**Description:** Creates a Stripe Checkout session to allow a user to subscribe to a paid plan.\n\n**Authentication Required:** No (The handler does not call `auth()`. It relies on `userId` and `email` being passed in the request body).\n\n**Route Handler:**\n```typescript\nimport { NextResponse } from \"next/server\";\nimport { stripe } from \"@/lib/stripe\";\n\nexport async function POST(request: Request) {\n  try {\n    const { planType, userId, email } = await request.json();\n\n    if (!planType || !userId || !email) {\n      // ... 400 response\n    }\n\n    const priceId = planType.toLowerCase() === 'premium'\n        ? process.env.NEXT_PUBLIC_STRIPE_PREMIUM\n        : process.env.NEXT_PUBLIC_STRIPE_BASIC;\n\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: ['card'],\n      line_items: [{\n        price: priceId,\n        quantity: 1,\n      }],\n      mode: 'subscription',\n      success_url: `${process.env.NEXT_PUBLIC_URL}/success?session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${process.env.NEXT_PUBLIC_URL}/cancel`,\n      customer_email: email,\n      metadata: { userId },\n    });\n\n    return NextResponse.json({ url: session.url });\n  } catch (error) {\n    // ... 500 response\n  }\n}\n```\n\n**Request Body Schema:**\nNo request schema defined in code. The handler expects a JSON body with the following properties:\n\n| Field | Type | Required | Description |\n|---|---|---|---|\n| `planType` | `string` | Yes | The type of plan to subscribe to (e.g., \"premium\", \"basic\"). |\n| `userId` | `string` | Yes | The Clerk user ID of the user subscribing. |\n| `email` | `string` | Yes | The user's email address. |\n\n**Response Schema:**\n*   **Source:** `omar-mostafa205-Planna-aea2b49/src/app/(main)/subscription/page.tsx`\n    ```typescript\n    type SubscriptionResponse = {\n      url: string;\n    };\n    ```\n\n**Error Responses:**\n\n| Status Code | Condition | Response |\n|---|---|---|\n| `400` | `planType`, `userId`, or `email` are missing from the request body. | `{\"error\": \"Plan type, user ID, and email are required\"}` |\n| `500` | An error occurred while creating the Stripe Checkout session. | `{\"error\": \"Failed to create checkout session\"}` |\n\n---\n\n### Webhooks\n\n#### `POST /api/webhook/clerk`\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/webhook/clerk/route.ts:6`\n\n**Description:** Inbound webhook to handle events from Clerk, primarily for creating a user profile in the local database when a user signs up.\n\n**Authentication Required:** No. The endpoint is public and does not perform signature verification.\n\n**Route Handler:**\n```typescript\nimport { prisma } from \"@/lib/prisma\";\nimport { NextResponse } from \"next/server\";\n\nexport const runtime = 'nodejs';\n\nexport async function POST(req: Request) {\n  try {\n    const { data } = await req.json() as { data: any };\n    // ... switch statement on data.object ...\n    const email = data?.email_addresses?.[0]?.email_address;\n    const clerkUserId = data?.id;\n\n    const profile = await prisma.$transaction(async (tx) => {\n      return tx.profile.upsert({\n        where: { userId: clerkUserId },\n        create: {\n          userId: clerkUserId,\n          email,\n          subscriptionActive: false,\n          subscriptionTier: null,\n          stripeSubscriptionId: null,\n        },\n        update: { email },\n      });\n    });\n\n    return NextResponse.json({ success: true, profile });\n  } catch (error) {\n    // ... 500 response\n  }\n}\n```\n\n**Database Operations:**\n*   Writes to: `Profile` (creates or updates a user profile).\n\n**Side Effects:**\n*   Creates a new user profile record in the database.\n\n---\n\n#### `POST /api/webhook/stripe`\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/api/webhook/stripe/route.ts:11`\n\n**Description:** Inbound webhook to handle subscription-related events from Stripe. It manages the user's subscription status in the local database.\n\n**Authentication Required:** Yes (Stripe webhook signature verification is attempted).\n\n**Route Handler:**\n```typescript\nimport Stripe from \"stripe\";\n// ...\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string);\nconst webhookSecret = process.env.STRIPE_WEBHOOK_KEY as string;\n\nexport async function POST(req: NextRequest) {\n  const body = await req.text();\n  const signature = req.headers.get(\"stripe-signature\");\n  let event: Stripe.Event;\n\n  try {\n    event = stripe.webhooks.constructEvent(body, signature!, webhookSecret);\n  } catch (err: any) {\n    // ... 400 response\n  }\n\n  switch (event.type) {\n    case \"checkout.session.completed\":\n      // ... handle session completed\n      break;\n    case \"invoice.payment_failed\":\n      // ... handle payment failed\n      break;\n    case \"customer.subscription.deleted\":\n      // ... handle subscription deleted\n      break;\n    default:\n      console.warn(`Unhandled event type: ${event.type}`);\n  }\n\n  return NextResponse.json({ received: true });\n}\n```\n\n**Logic:**\n*   **`checkout.session.completed`**: When a user successfully subscribes, this event is triggered. The handler finds the user's profile via the `userId` in the session metadata and updates it with the new `stripeSubscriptionId`, `subscriptionTier`, and sets `subscriptionActive` to `true`.\n*   **`invoice.payment_failed`**: If a recurring payment fails, this handler finds the user's profile via the `stripeSubscriptionId` and sets `subscriptionActive` to `false`.\n*   **`customer.subscription.deleted`**: When a subscription is canceled or ends, this handler finds the user's profile and sets `subscriptionActive` to `false` and `stripeSubscriptionId` to `null`.\n\n**Database Operations:**\n*   Reads from: `Profile`\n*   Writes to: `Profile`\n\n---\n\n## Data Models\n\n⚠️ No `schema.prisma` file was found in the provided codebase. The following model schema is inferred from Prisma client usage in the API routes.\n\n### Profile\n\n**Source:** Inferred from `omar-mostafa205-Planna-aea2b49/src/app/api/**/*.ts`\n\n**Database Table/Collection:** `profile`\n\n**Inferred Schema Definition:**\nBased on queries, the `Profile` model likely contains the following fields.\n\n**Field Details:**\n\n| Field | Type | Required | Inferred From |\n|---|---|---|---|\n| `userId` | `String` | Yes | `where: { userId }` clause in multiple files. Serves as the primary/unique key linking to Clerk's user ID. (`webhook/clerk/route.ts`) |\n| `email` | `String` | Yes | `create: { email }` in `webhook/clerk/route.ts` |\n| `mealPlan` | `Json?` | No | `data: { mealPlan: mealPlanJson }` in `generate-plan/route.ts`. The `?` denotes it's optional as it's not set on creation. |\n| `subscriptionActive`| `Boolean` | Yes | `create: { subscriptionActive: false }` in `webhook/clerk/route.ts` and updates in `webhook/stripe/route.ts`. |\n| `subscriptionTier`| `String?` | No | `create: { subscriptionTier: null }` in `webhook/clerk/route.ts` and updates in `webhook/stripe/route.ts`. |\n| `stripeSubscriptionId`| `String?` | No | `create: { stripeSubscriptionId: null }` in `webhook/clerk/route.ts`. Used as a unique key for lookups in `webhook/stripe/route.ts`. |\n\n**Relationships:**\nNo relationships to other models were found in the codebase.\n\n---\n\n## Type Definitions\n\n### MealPlanData\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/(main)/dashboard/page.tsx`\n\n**Definition:**\nThis client-side interface defines the expected structure of a meal plan object, which corresponds to the data returned by `GET /api/get-plan` and `POST /api/generate-plan`.\n\n```typescript\ninterface MealPlanData {\n  calories: number;\n  protein: number;\n  carbs: number;\n  fat: number;\n  currentWeight: number;\n  bodyFat: number;\n  muscleMass: number;\n  goal: string;\n  meals: {\n    breakfast: Meal;\n    lunch: Meal;\n    dinner: Meal;\n    snack: Meal;\n  };\n}\n```\n\n**Related Types:**\n*   `Meal`\n\n### Meal\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/app/(main)/dashboard/page.tsx`\n\n**Definition:**\nDefines the structure for an individual meal within the `MealPlanData` type.\n```typescript\ninterface Meal {\n  title: string;\n  calories: number;\n  protein: number;\n  carbs: number;\n  fat: number;\n  ingredients: string[];\n  instructions: string[];\n}\n```\n\n---\n\n## Business Logic & Services\n\n### Image Service\n\n**Location:** `omar-mostafa205-Planna-aea2b49/src/lib/image.ts`\n\n**Purpose:** Provides utility functions for handling and processing images, primarily for the InBody scan upload feature.\n\n#### `compressImageServer()`\n\n**Signature:**\n```typescript\nexport async function compressImageServer(buffer: ArrayBuffer): Promise<Buffer>\n```\n\n**Implementation:**\n```typescript\nexport async function compressImageServer(buffer: ArrayBuffer): Promise<Buffer> {\n  const compressedBuffer = await sharp(buffer)\n    .webp({ quality: 80 })\n    .resize({ height: 800, withoutEnlargement: true })\n    .toBuffer();\n\n  return compressedBuffer;\n}\n```\n\n**Parameters:**\n\n| Parameter | Type | Required | Description |\n|---|---|---|---|\n| `buffer` | `ArrayBuffer` | Yes | The raw image data as an `ArrayBuffer`. |\n\n**Returns:** `Promise<Buffer>` - A `Promise` that resolves to a `Buffer` containing the compressed image data in WebP format.\n\n**Dependencies:**\n*   `sharp`\n\n---\n\n## Middleware\n\n### Clerk Authentication Middleware\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/middleware.ts`\n\n**Purpose:** This middleware from Clerk handles session management and authentication for the entire application. It ensures that user authentication state is available across both pages and API routes.\n\n**Implementation:**\n```typescript\nimport { clerkMiddleware } from \"@clerk/nextjs/server\";\n\nexport default clerkMiddleware();\n\nexport const config = {\n  matcher: [\n    // Skip Next.js internals and all static files, unless found in search params\n    '/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',\n    // Always run for API routes\n    '/(api|trpc)(.*)',\n  ],\n};\n```\n\n**Applied To:**\nThe middleware is applied to all routes matching the `matcher` config, which includes all API routes (`/api/*`) and application pages, while excluding static assets and Next.js internal paths.\n\n---\n\n## Validation\n\n**Validation Library:** Zod\n\n### Client Profile Form Schema\n\nThis schema is used on the **client-side** to validate user input before submitting the form to the `POST /api/generate-plan` endpoint. The backend API endpoint does not currently re-validate this data.\n\n**Source:** `omar-mostafa205-Planna-aea2b49/src/components/Form.tsx`\n\n```typescript\nconst formSchema = z.object({\n  // Client Information\n  fullName: z.string().min(2, { message: \"Full name must be at least 2 characters long\" }),\n  age: z.string().refine((val) => /^\\\\d+$/.test(val) && parseInt(val) > 0 && parseInt(val) < 150, { \n    message: \"Age must be a valid number between 1 and 149\" \n  }),\n  height: z.string().refine((val) => /^\\\\d+$/.test(val) && parseInt(val) > 0 && parseInt(val) < 300, { \n    message: \"Height must be a valid number in cm\" \n  }),\n  gender: z.enum([\"Male\", \"Female\", \"Other\"], { required_error: \"Gender is required\" }),\n  activityLevel: z.enum([\"Sedentary\", \"Lightly active\", \"Active\", \"Very active\"], {\n    required_error: \"Activity level is required\",\n  }),\n  goals: z.string().min(5, { message: \"Please enter the client's goals.\" }),\n  medicalConditions: z.string().optional(),\n  images: z.array(z.instanceof(File)).min(1, {\n    message: 'Design image is required',\n  }),\n});\n```\n\n**Used In:**\n*   The form component in `omar-mostafa205-Planna-aea2b49/src/components/Form.tsx`.\n\n---\n\n## Configuration & Environment\n\n**Environment Variables Used:**\n\n| Variable | Used In | Purpose |\n|---|---|---|\n| `OPENROUTER_API_KEY` | `src/app/api/generate-plan/route.ts` | API key for OpenRouter to access OpenAI models. |\n| `STRIPE_SECRET_KEY` | `src/lib/stripe.ts`, `src/app/api/webhook/stripe/route.ts` | Secret key for authenticating with the Stripe API. |\n| `STRIPE_WEBHOOK_KEY` | `src/app/api/webhook/stripe/route.ts` | Secret key for verifying incoming Stripe webhooks. |\n| `NEXT_PUBLIC_STRIPE_PREMIUM` | `src/app/api/check-out/route.ts`, `src/lib/constants.ts` | Stripe Price ID for the \"Premium\" subscription plan. |\n| `NEXT_PUBLIC_STRIPE_BASIC` | `src/app/api/check-out/route.ts`, `src/lib/constants.ts` | Stripe Price ID for the \"Basic\" subscription plan. |\n| `NEXT_PUBLIC_URL` | `src/app/api/check-out/route.ts` | The base URL of the application, used for Stripe success/cancel URLs. |\n\n---\n\n## Limitations of This Documentation\n\n-   Generated from static code analysis of AST.\n-   Runtime behavior may differ from static analysis.\n-   The `schema.prisma` file was not included in the AST, so the Data Models section is based on inference from database queries. The actual schema may contain additional fields, constraints, or relations.\n-   Dynamic routes or programmatically generated endpoints may not be captured.\n-   Environment-specific configurations may not be visible.\n-   **This documentation only includes what exists in the provided code.**\n\n---\n\n## Recommendations for Improvement\n\n-   **Missing Database Schema:** The Prisma schema file (`schema.prisma`) should be included in the analysis for accurate data modeling.\n-   **Backend Validation:** The `POST /api/generate-plan` endpoint implicitly trusts the `FormData` from the client. It should implement its own server-side validation (e.g., using Zod) to ensure data integrity and security.\n-   **Webhook Security:** The `POST /api/webhook/clerk` endpoint does not appear to verify webhook signatures, which is a critical security practice to prevent unauthorized requests.\n-   **Authentication on Checkout:** The `POST /api/check-out` endpoint accepts `userId` from the request body without verifying the user's session. This could allow one user to initiate a checkout session for another. This endpoint should be protected with `auth()`."